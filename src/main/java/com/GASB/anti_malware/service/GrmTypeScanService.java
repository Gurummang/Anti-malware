//package com.GASB.anti_malware.service;
//
//import com.GASB.anti_malware.model.entity.TypeScan;
//import com.GASB.anti_malware.repository.TypeScanRepository;
//import org.springframework.scheduling.annotation.Async;
//import org.springframework.stereotype.Service;
//import org.apache.tika.Tika;
//import org.springframework.transaction.annotation.Transactional;
//
//import java.io.File;
//import java.io.FileInputStream;
//import java.io.IOException;
//
//// 구름망 STEP 1과 관련된 서비스
//@Service
//public class GrmTypeScanService {
//
//    private final Tika tika;
//    private final TypeScanRepository typeScanRepository;
//    // private final FileUploadRepository fileUploadRepository;
//
//    public GrmTypeScanService(TypeScanRepository typeScanRepository) {
//        this.tika = new Tika();
//        this.typeScanRepository = typeScanRepository;
//    }
//
//    @Async
//    @Transactional
//    public void GrmStep1(long uploadId) throws IOException {
//        // uploadId로 filename 찾는 로직 작성
//        // filePath는 로컬에 다운로드한 경로
//        String fileName = "filename";
//        String filePath = "your_local_file_path";
//
//        if (filePath == null) {
//            // Log or handle error
//            return;
//        }
//
//        // 로컬 경로 삽입
//        File file = new File(filePath);
//        if (!file.exists()) {
//            // Log or handle error
//            return;
//        }
//
//        boolean match;
//
//        try (FileInputStream inputStream = new FileInputStream(file)) {
//            String mimeType = tika.detect(inputStream); // 파일 mime 타입 추출
//            String fileExtension = getFileExtension(fileName);
//            String expectedMimeType = MimeType.getMimeTypeByExtension(fileExtension); // MimeType enum에 메소드 존재
//            String headerSignature = getActualFileSignature(file, fileExtension);
//
//            if ("unknown".equals(headerSignature)) {
//                // 헤더 시그니처가 "unknown"인 경우, 예상 MIME 타입이 실제 MIME 타입과 일치하는지 확인
//                match = expectedMimeType != null && expectedMimeType.equals(mimeType);
//            } else if (!headerSignature.equals(fileExtension)) {
//                // 헤더 시그니처가 파일 확장자와 일치하지 않는 경우, 일치하지 않음으로 설정
//                match = false;
//            } else {
//                // 그렇지 않은 경우, 예상 MIME 타입이 실제 MIME 타입과 일치하는지 확인
//                match = expectedMimeType != null && expectedMimeType.equals(mimeType);
//            }
//
//            // Save to ScanTable
//            TypeScan typeScan = TypeScan.builder()
//                    .match(match)
//                    .signature(headerSignature)
//                    .mimetype(mimeType)
//                    .extension(fileExtension)
//                    .build();
//            typeScanRepository.save(typeScan);
//        }
//    }
//
//    // 파일 확장자 추출
//    private String getFileExtension(String fileName) {
//        // 파일 이름에서 마지막 '.'의 인덱스를 찾음
//        int lastDotIndex = fileName.lastIndexOf('.');
//
//        // 마지막 '.'이 존재하고, '.'이 파일 이름의 끝이 아닌 경우
//        if (lastDotIndex != -1 && lastDotIndex < fileName.length() - 1) {
//            // '.' 이후의 문자열을 반환하며, 소문자로 변환
//            return fileName.substring(lastDotIndex + 1).toLowerCase();
//        }
//
//        // '.'이 없거나, '.'이 파일 이름의 마지막인 경우 "unknown" 반환
//        return "unknown";
//    }
//
//
//    // 파일 헤더 시그니처 추출
//    private String getActualFileSignature(File file, String fileExtension) throws IOException {
//        // 파일 확장자에 따라 헤더 시그니처의 길이를 가져옴
//        int signatureLength = HeaderSignature.getSignatureLengthByExtension(fileExtension);
//        byte[] header = new byte[signatureLength];
//
//        // 파일 스트리밍 방식으로 읽어옴
//        try (FileInputStream inputStream = new FileInputStream(file)) {
//            // 파일의 헤더 부분을 읽어서 header 배열에 저장
//            inputStream.read(header, 0, signatureLength);
//        }
//
//        // 바이트 배열을 헥사 문자열로 변환
//        StringBuilder sb = new StringBuilder();
//        for (byte b : header) {
//            sb.append(String.format("%02X", b));
//        }
//        String hexSignature = sb.toString();
//
//        // HeaderSignature enum에 정의된 시그니처와 비교하여 확장자 반환
//        for (HeaderSignature hs : HeaderSignature.values()) {
//            if (hs.getSignature().equals(hexSignature)) {
//                return hs.getExtension();
//            }
//        }
//        // 일치하는 시그니처가 없으면 "unknown" 반환
//        return "unknown";
//    }
//
//}