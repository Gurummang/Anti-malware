package com.GASB.anti_malware.service;

import com.GASB.anti_malware.model.entity.FileStatus;
import com.GASB.anti_malware.model.entity.ScanTable;
import com.GASB.anti_malware.model.entity.StoredFile;
import com.GASB.anti_malware.repository.FileStatusRepository;
import com.GASB.anti_malware.repository.ScanTableRepository;
import com.GASB.anti_malware.repository.StoredFileRepository;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Service;
import org.apache.tika.Tika;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;

// STEP 1과 관련된 서비스 (곧 사라질 각..)
@Service
public class InnerCheckService {

    private final Tika tika;
    private final ScanTableRepository scanTableRepository;
    private final StoredFileRepository storedFileRepository;
    private final FileStatusRepository fileStatusRepository;

    public InnerCheckService(ScanTableRepository scanTableRepository, StoredFileRepository storedFileRepository, FileStatusRepository fileStatusRepository) {
        this.tika = new Tika();
        this.scanTableRepository = scanTableRepository;
        this.storedFileRepository = storedFileRepository;
        this.fileStatusRepository = fileStatusRepository;
    }

    @Async
    public void detectMimeType(long fileId) throws IOException {
        StoredFile storedFile = storedFileRepository.findById(fileId);
        String filePath = storedFileRepository.findSavePathById(fileId);
        if (filePath == null) {
            // Log or handle error
            System.out.println("Error: File not found");
            return;
        }

        File file = new File(filePath);
        if (!file.exists()) {
            // Log or handle error
            System.out.println("Error: File not found at " + filePath);
            return;
        }

        updateFileStatusToInProgress(fileId, 0);

        String resultMessage;

        try (FileInputStream inputStream = new FileInputStream(file)) {
            String mimeType = tika.detect(inputStream);
            String fileExtension = getFileExtension(filePath);
            String expectedMimeType = MimeType.getMimeTypeByExtension(fileExtension);
            String headerSignature = getActualFileSignature(file, fileExtension);

            if ("unknown".equals(headerSignature)) {
                if (expectedMimeType != null && expectedMimeType.equals(mimeType)) {
                    resultMessage = "match"; // MIME 타입이 일치하면 match
                } else {
                    resultMessage = "unmatch"; // MIME 타입이 불일치하면 unmatch
                }
            } else if (!headerSignature.equals(fileExtension)) {
                resultMessage = "unmatch"; // 헤더 시그니처가 파일 확장자와 다르면 unmatch
            } else if (expectedMimeType != null && expectedMimeType.equals(mimeType)) {
                resultMessage = "match"; // MIME 타입이 일치하고 헤더 시그니처가 파일 확장자와 같으면 match
            } else {
                resultMessage = "unmatch"; // 모든 다른 경우는 unmatch
            }

            // Save to ScanTable
            ScanTable scanTable = ScanTable.builder()
                    .storedFile(storedFile)
                    .build();
            scanTableRepository.save(scanTable);
            updateFileStatusToInProgress(fileId, 1);
        }
    }

    private void updateFileStatusToInProgress(long fileId, int num) {
        FileStatus fileStatus = fileStatusRepository.findByStoredFileId(fileId);
        if (fileStatus != null) {
            fileStatus.setGscanStatus(num);
            fileStatusRepository.save(fileStatus);
        }
    }

    private String getFileExtension(String filePath) {
        int lastDotIndex = filePath.lastIndexOf('.');
        if (lastDotIndex != -1 && lastDotIndex < filePath.length() - 1) {
            return filePath.substring(lastDotIndex + 1).toLowerCase();
        }
        return "";
    }

    private String getActualFileSignature(File file, String fileExtension) throws IOException {
        int signatureLength = HeaderSignature.getSignatureLengthByExtension(fileExtension);
        byte[] header = new byte[signatureLength];

        try (FileInputStream inputStream = new FileInputStream(file)) {
            inputStream.read(header, 0, signatureLength);
        }

        StringBuilder sb = new StringBuilder();
        for (byte b : header) {
            sb.append(String.format("%02X", b));
        }
        String hexSignature = sb.toString();

        for (HeaderSignature hs : HeaderSignature.values()) {
            if (hs.getSignature().equals(hexSignature)) {
                return hs.getExtension();
            }
        }
        return "unknown";
    }
}