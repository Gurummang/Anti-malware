package com.GASB.anti_malware.service;

import com.GASB.anti_malware.model.dto.response.Step1ScanDto;
import com.GASB.anti_malware.model.entity.FileStatus;
import com.GASB.anti_malware.model.entity.ScanTable;
import com.GASB.anti_malware.model.entity.StoredFile;
import com.GASB.anti_malware.repository.FileStatusRepository;
import com.GASB.anti_malware.repository.ScanTableRepository;
import com.GASB.anti_malware.repository.StoredFileRepository;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Service;
import org.apache.tika.Tika;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;

@Service
public class InnerCheckService {

    private final Tika tika;
    private final ScanTableRepository scanTableRepository;
    private final StoredFileRepository storedFileRepository;
    private final FileStatusRepository fileStatusRepository;

    public InnerCheckService(ScanTableRepository scanTableRepository, StoredFileRepository storedFileRepository, FileStatusRepository fileStatusRepository) {
        this.tika = new Tika();
        this.scanTableRepository = scanTableRepository;
        this.storedFileRepository = storedFileRepository;
        this.fileStatusRepository = fileStatusRepository;
    }

    @Async
    public void detectMimeType(long fileId) throws IOException {
        StoredFile storedFile = storedFileRepository.findById(fileId);
        String filePath = storedFileRepository.findSavePathById(fileId);
        if (filePath == null) {
            // Log or handle error
            System.out.println("Error: File not found");
            return;
        }

        File file = new File(filePath);
        if (!file.exists()) {
            // Log or handle error
            System.out.println("Error: File not found at " + filePath);
            return;
        }

        updateFileStatusToInProgress(fileId, 0);
        int level = 0;

        String resultMessage;
        String detectType;

        try (FileInputStream inputStream = new FileInputStream(file)) {
            String mimeType = tika.detect(inputStream);
            String fileExtension = getFileExtension(filePath);
            String expectedMimeType = MimeType.getMimeTypeByExtension(fileExtension);

            if (expectedMimeType != null && expectedMimeType.equals(mimeType)) {
                detectType = mimeType;
                resultMessage = "MIME type matches";
            } else {
                detectType = mimeType;
                resultMessage = "MIME type does not match";
                level += 1;
            }

            // Prepare the JSON-like string to save
            Step1ScanDto step1ScanDto = Step1ScanDto.builder()
                    .detect(detectType)
                    .message(resultMessage)
                    .build();
            String step1DetailJson = new ObjectMapper().writeValueAsString(step1ScanDto);

            // Save to ScanTable
            ScanTable scanTable = ScanTable.builder()
                    .storedFile(storedFile)
                    .step1Detail(step1DetailJson) // Save JSON as text
                    .level(level)
                    .build();
            scanTableRepository.save(scanTable);
            updateFileStatusToInProgress(fileId, 1);
        }
    }

    private void updateFileStatusToInProgress(long fileId, int num) {
        FileStatus fileStatus = fileStatusRepository.findByStoredFileId(fileId);
        if (fileStatus != null) {
            fileStatus.setGscanStatus(num);
            fileStatusRepository.save(fileStatus);
        }
    }

    private String getFileExtension(String filePath) {
        int lastDotIndex = filePath.lastIndexOf('.');
        if (lastDotIndex != -1 && lastDotIndex < filePath.length() - 1) {
            return filePath.substring(lastDotIndex + 1).toLowerCase();
        }
        return "";
    }
}
