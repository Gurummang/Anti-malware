package com.GASB.anti_malware.service;

import com.GASB.anti_malware.domain.VtReport;
import com.GASB.anti_malware.repository.VtReportRepository;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.web.client.HttpClientErrorException;
import org.springframework.web.client.RestTemplate;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpMethod;

import java.io.IOException;

@Service
public class VtReportSaveService {

    @Value("${virustotal.api.key}")
    private String apikey;

    private final RestTemplate restTemplate;
    private final ObjectMapper objectMapper;
    private final VtReportRepository reportRepository;

    public VtReportSaveService(VtReportRepository reportRepository){
        this.restTemplate = new RestTemplate();
        this.objectMapper = new ObjectMapper();
        this.reportRepository = reportRepository;
    }

    public String getReport(String hash){
        // hash 값을 읽어와야 함
        String url = "https://www.virustotal.com/api/v3/files/" + hash;
        HttpHeaders headers = new HttpHeaders();
        headers.set("accept", "application/json");
        headers.set("x-apikey", apikey);

        HttpEntity<String> entity = new HttpEntity<>(headers);

        try{
            String response = restTemplate.exchange(url, HttpMethod.GET, entity, String.class).getBody();
            saveReportToDatabase(hash, response);
            return "report saved as databases";
        } catch (HttpClientErrorException e) {
            return "Error fetching report: " + e.getMessage();
        }
    }

    public void saveReportToDatabase(String hash, String response) {
        try{
            JsonNode jsonNode = objectMapper.readTree(response);
            JsonNode scansNode = jsonNode.path("data").path("attributes").path("last_analysis_results");
            JsonNode statsNode = jsonNode.path("data").path("attributes").path("last_analysis_stats");
            JsonNode labelNode = jsonNode.path("data").path("attribute").path("popular_threat_category");
            String type = jsonNode.path("data").path("attribute").path("type_extension").asText();

            int malicious = statsNode.path("malicious").asInt();
            int suspicious = statsNode.path("suspicious").asInt();
            int undetected = statsNode.path("undetected").asInt();
            int harmless = statsNode.path("harmless").asInt();
            int detected_engine = malicious + suspicious;
            int completed_engine = malicious + suspicious + undetected + harmless;
            int score = detected_engine/completed_engine * 100;

            String alYac = extractEngineResult(scansNode, "ALYac");
            String v3 = extractEngineResult(scansNode, "AhnLab-V3");
            String kaspersky = extractEngineResult(scansNode, "Kaspersky");
            String falcon = extractEngineResult(scansNode, "CrowdStrike");
            String avast = extractEngineResult(scansNode,"Avast");
            String sentinelOne = extractEngineResult(scansNode, "SentinelOne");

            VtReport report = VtReport.builder()
                    .file_id(1L)
                    .type(type)
                    .ALYac(alYac)
                    .V3(v3)
                    .Kaspersky(kaspersky)
                    .Falcon(falcon)
                    .Avast(avast)
                    .Sentinelone(sentinelOne)
                    .detect_engine(detected_engine)
                    .complete_engine(completed_engine)
                    .score(score)
                    .threat_label(threatLabel(labelNode))
                    .report_url("https://www.virustotal.com/gui/file/" + hash)
                    .build();

            reportRepository.save(report);

        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private String extractEngineResult(JsonNode scansNode, String engineName) {
        JsonNode engineNode = scansNode.path(engineName);
        if (!engineNode.isMissingNode()) {
            String category = engineNode.path("category").asText();
            if (category.equals("malicious")) {
                return engineNode.path("result").asText();
            } else if (category.equals("undetected")) {
                return "undetected";
            }
        }
        return null;
    }

    private String threatLabel(JsonNode labelNode) {
        JsonNode threatLabelNode = labelNode.path("suggested_threat_label");
        if (!threatLabelNode.isMissingNode()) {
            return threatLabelNode.asText();
        } else {
            return "none";
        }
    }
}
