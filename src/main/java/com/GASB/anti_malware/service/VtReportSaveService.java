package com.GASB.anti_malware.service;

import com.GASB.anti_malware.model.dto.response.Result;
import com.GASB.anti_malware.model.dto.response.VtReportDto;
import com.GASB.anti_malware.model.entity.VtReport;
import com.GASB.anti_malware.model.entity.StoredFile;
import com.GASB.anti_malware.repository.StoredFileRepository;
import com.GASB.anti_malware.repository.VtReportRepository;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.modelmapper.ModelMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.*;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Service;
import org.springframework.web.client.HttpClientErrorException;
import org.springframework.web.client.RestTemplate;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;

@Service
public class VtReportSaveService {

    private static final Logger logger = LoggerFactory.getLogger(VtReportSaveService.class);

    @Value("${virustotal.api.key}")
    private String apikey;

    private final String BASE_URL = "https://www.virustotal.com/api/v3";


    private final RestTemplate restTemplate;
    private final ObjectMapper objectMapper;
    private final ModelMapper modelMapper;
    private final VtReportRepository reportRepository;
    private final StoredFileRepository storedFileRepository;
    private final FileStatusService fileStatusService;

    @Autowired
    public VtReportSaveService(RestTemplate restTemplate, VtReportRepository reportRepository, StoredFileRepository storedFileRepository
            , ModelMapper modelMapper, FileStatusService fileStatusService) {
        this.restTemplate = restTemplate;
        this.objectMapper = new ObjectMapper();
        this.reportRepository = reportRepository;
        this.storedFileRepository = storedFileRepository;
        this.modelMapper = modelMapper;
        this.fileStatusService = fileStatusService;
    }

    @Async("taskExecutor")
    public void processReport(Long fileId) {
        // VT 리포트를 가져옵니다.
        HttpStatusCode reportResult = saveReportById(fileId);

        // 리포트가 성공적으로 저장된 경우 상태 업데이트
        if (reportResult == HttpStatus.OK) {
            fileStatusService.updateVtStatus(fileId, 1); // vtStatus를 1로 업데이트
        }
    }

    public HttpStatusCode saveReportById(long fileId) {
        StoredFile storedFile = storedFileRepository.findById(fileId);
        if (storedFile == null) {
            return HttpStatus.NOT_FOUND;
        }

        String hash = storedFile.getSaltedHash(); // Assuming SaltedHash is the hash value you want to retrieve
        String url = BASE_URL + "/files/" + hash;
        HttpHeaders headers = new HttpHeaders();
        headers.set("accept", "application/json");
        headers.set("x-apikey", apikey);

        HttpEntity<String> entity = new HttpEntity<>(headers);

        try {
            ResponseEntity<String> responseEntity = restTemplate.exchange(url, HttpMethod.GET, entity, String.class);
            HttpStatusCode statusCode = responseEntity.getStatusCode();

            if (statusCode == HttpStatus.NOT_FOUND) {
                return HttpStatus.NOT_FOUND;
            } else if (statusCode.is2xxSuccessful()) {
                String response = responseEntity.getBody();
                saveReportToDatabase(response, storedFile);
                return HttpStatus.OK;
            } else {
                return statusCode;
            }
        } catch (HttpClientErrorException e) {
            return e.getStatusCode();
        } catch (Exception e) {
            // Handle unexpected exceptions
            logger.error("Unexpected error while saving report by ID: {}", fileId, e);
            return HttpStatus.INTERNAL_SERVER_ERROR;
        }
    }

    private void saveReportToDatabase(String response, StoredFile storedFile) {
        try {
            JsonNode jsonNode = objectMapper.readTree(response);
            JsonNode attributesNode = jsonNode.path("data").path("attributes");

            VtReportDto reportDto = parseVtReportDto(attributesNode, storedFile);
            VtReport report = modelMapper.map(reportDto, VtReport.class);
            report.setStoredFile(storedFile); // manually set the StoredFile reference
            reportRepository.save(report);

        } catch (IOException e) {
            logger.error("Failed to save report to database for file ID: {}", storedFile.getId(), e);
        }
    }

    private VtReportDto parseVtReportDto(JsonNode attributesNode, StoredFile storedFile) {
        VtReportDto reportDto = new VtReportDto();
        reportDto.setType(attributesNode.path("type_extension").asText());
        reportDto.setV3(extractEngineResult(attributesNode, "AhnLab-V3"));
        reportDto.setAlyac(extractEngineResult(attributesNode, "ALYac"));
        reportDto.setKaspersky(extractEngineResult(attributesNode, "Kaspersky"));
        reportDto.setFalcon(extractEngineResult(attributesNode, "CrowdStrike"));
        reportDto.setAvast(extractEngineResult(attributesNode, "Avast"));
        reportDto.setSentinelone(extractEngineResult(attributesNode, "SentinelOne"));
        reportDto.setDetectEngine(calculateDetectedEngine(attributesNode));
        reportDto.setCompleteEngine(calculateCompletedEngine(attributesNode));
        reportDto.setScore(calculateScore(reportDto.getDetectEngine(), reportDto.getCompleteEngine()));
        reportDto.setThreatLabel(extractThreatLabel(attributesNode.path("popular_threat_classification")));
        reportDto.setReportUrl("https://www.virustotal.com/gui/file/" + storedFile.getSaltedHash());

        return reportDto;
    }

    private int calculateDetectedEngine(JsonNode attributesNode) {
        int malicious = attributesNode.path("last_analysis_stats").path("malicious").asInt();
        int suspicious = attributesNode.path("last_analysis_stats").path("suspicious").asInt();
        return malicious + suspicious;
    }

    private int calculateCompletedEngine(JsonNode attributesNode) {
        JsonNode statsNode = attributesNode.path("last_analysis_stats");
        int malicious = statsNode.path("malicious").asInt();
        int suspicious = statsNode.path("suspicious").asInt();
        int undetected = statsNode.path("undetected").asInt();
        int harmless = statsNode.path("harmless").asInt();
        return malicious + suspicious + undetected + harmless;
    }

    private int calculateScore(int detected_engine, int completed_engine) {
        return completed_engine > 0 ? (detected_engine * 100 / completed_engine) : 0;
    }

    private String extractThreatLabel(JsonNode labelNode) {
        JsonNode threatLabelNode = labelNode.path("suggested_threat_label");
        return threatLabelNode.isMissingNode() ? "none" : threatLabelNode.asText();
    }

    private String extractEngineResult(JsonNode attributesNode, String engineName) {
        JsonNode scansNode = attributesNode.path("last_analysis_results");
        JsonNode engineNode = scansNode.path(engineName);
        if (!engineNode.isMissingNode()) {
            String category = engineNode.path("category").asText();
            if ("malicious".equals(category)) {
                return engineNode.path("result").asText();
            } else if ("undetected".equals(category)) {
                return "undetected";
            } else {
                return "type-unsupported";
            }

        }
        return null;
    }

}
