package com.GASB.anti_malware.service;

import com.GASB.anti_malware.model.dto.response.VtReportDto;
import com.GASB.anti_malware.model.entity.VtReport;
import com.GASB.anti_malware.model.entity.StoredFile;
import com.GASB.anti_malware.repository.StoredFileRepository;
import com.GASB.anti_malware.repository.VtReportRepository;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.modelmapper.ModelMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpMethod;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Service;
import org.springframework.web.client.HttpClientErrorException;
import org.springframework.web.client.RestTemplate;

import java.io.IOException;

@Service
public class VtReportSaveService {

    @Value("${virustotal.api.key}")
    private String apikey;

    private final String BASE_URL = "https://www.virustotal.com/api/v3";


    private final RestTemplate restTemplate;
    private final ObjectMapper objectMapper;
    private final ModelMapper modelMapper;
    private final VtReportRepository reportRepository;
    private final StoredFileRepository storedFileRepository;
    private final StoredFileService storedFileService;

    @Autowired
    public VtReportSaveService(RestTemplate restTemplate, VtReportRepository reportRepository, StoredFileRepository storedFileRepository
            , ModelMapper modelMapper, StoredFileService storedFileService) {
        this.restTemplate = restTemplate;
        this.objectMapper = new ObjectMapper();
        this.reportRepository = reportRepository;
        this.storedFileRepository = storedFileRepository;
        this.modelMapper = modelMapper;
        this.storedFileService = storedFileService;
    }

    @Async
    public void processReport(Long fileId) {
        // VT 리포트를 가져옵니다.
        String reportResult = saveReportById(fileId);

        // 리포트가 성공적으로 저장된 경우 상태 업데이트
        if (!reportResult.contains("404")) {
            storedFileService.updateVtStatus(fileId, 1); // vtStatus를 1로 업데이트
        }
    }


    public String saveReportById(long fileId) {
        StoredFile storedFile = storedFileRepository.findById(fileId);
        if (storedFile == null) {
            return "Error: File with id " + fileId + " not found";
        }

        String hash = storedFile.getSaltedHash(); // Assuming SaltedHash is the hash value you want to retrieve
        String url = BASE_URL + "/files/" + hash;
        HttpHeaders headers = new HttpHeaders();
        headers.set("accept", "application/json");
        headers.set("x-apikey", apikey);

        HttpEntity<String> entity = new HttpEntity<>(headers);

        try {
            String response = restTemplate.exchange(url, HttpMethod.GET, entity, String.class).getBody();
            // 여기에 응답을 검사하여 리포트가 있는지 확인
            if (response.contains("NotFoundError")) { // 404 오류 메시지 검사
                return "404 Not Found Error for file ID " + fileId;
            }
            saveReportToDatabase(response, storedFile);
            return "report saved in database";
        } catch (HttpClientErrorException e) {
            return e.getMessage();
        }
    }


    private void saveReportToDatabase(String response, StoredFile storedFile) {
        try {
            JsonNode jsonNode = objectMapper.readTree(response);
            JsonNode attributesNode = jsonNode.path("data").path("attributes");

            VtReportDto reportDto = parseVtReportDto(attributesNode, storedFile);
            VtReport report = modelMapper.map(reportDto, VtReport.class);
            report.setStoredFile(storedFile); // manually set the StoredFile reference
            reportRepository.save(report);

        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private VtReportDto parseVtReportDto(JsonNode attributesNode, StoredFile storedFile) {
        VtReportDto reportDto = new VtReportDto();
        reportDto.setType(attributesNode.path("type_extension").asText());
        reportDto.setV3(extractEngineResult(attributesNode, "AhnLab-V3"));
        reportDto.setAlyac(extractEngineResult(attributesNode, "ALYac"));
        reportDto.setKaspersky(extractEngineResult(attributesNode, "Kaspersky"));
        reportDto.setFalcon(extractEngineResult(attributesNode, "CrowdStrike"));
        reportDto.setAvast(extractEngineResult(attributesNode, "Avast"));
        reportDto.setSentinelone(extractEngineResult(attributesNode, "SentinelOne"));
        reportDto.setDetectEngine(calculateDetectedEngine(attributesNode));
        reportDto.setCompleteEngine(calculateCompletedEngine(attributesNode));
        reportDto.setScore(calculateScore(reportDto.getDetectEngine(), reportDto.getCompleteEngine()));
        reportDto.setThreatLabel(extractThreatLabel(attributesNode.path("popular_threat_category")));
        reportDto.setReportUrl("https://www.virustotal.com/gui/file/" + storedFile.getSaltedHash());

        return reportDto;
    }

    private int calculateDetectedEngine(JsonNode attributesNode) {
        int malicious = attributesNode.path("last_analysis_stats").path("malicious").asInt();
        int suspicious = attributesNode.path("last_analysis_stats").path("suspicious").asInt();
        return malicious + suspicious;
    }

    private int calculateCompletedEngine(JsonNode attributesNode) {
        JsonNode statsNode = attributesNode.path("last_analysis_stats");
        int malicious = statsNode.path("malicious").asInt();
        int suspicious = statsNode.path("suspicious").asInt();
        int undetected = statsNode.path("undetected").asInt();
        int harmless = statsNode.path("harmless").asInt();
        return malicious + suspicious + undetected + harmless;
    }

    private int calculateScore(int detected_engine, int completed_engine) {
        return completed_engine > 0 ? (detected_engine * 100 / completed_engine) : 0;
    }

    private String extractThreatLabel(JsonNode labelNode) {
        JsonNode threatLabelNode = labelNode.path("suggested_threat_label");
        return threatLabelNode.isMissingNode() ? "none" : threatLabelNode.asText();
    }

    private String extractEngineResult(JsonNode attributesNode, String engineName) {
        JsonNode scansNode = attributesNode.path("last_analysis_results");
        JsonNode engineNode = scansNode.path(engineName);
        if (!engineNode.isMissingNode()) {
            String category = engineNode.path("category").asText();
            if ("malicious".equals(category)) {
                return engineNode.path("result").asText();
            } else if ("undetected".equals(category)) {
                return "undetected";
            } else if("type-unsupported".equals(category)) {
                return "type-unsupported";
            }
        }
        return null;
    }

}
