package com.GASB.anti_malware.service;

import com.GASB.anti_malware.config.RabbitMQProperties;
import com.GASB.anti_malware.model.entity.FileStatus;
import com.GASB.anti_malware.model.entity.FileUpload;
import com.GASB.anti_malware.model.entity.StoredFile;
import com.GASB.anti_malware.repository.file.FileUploadRepo;
import com.GASB.anti_malware.repository.file.StoredFileRepo;
import com.GASB.anti_malware.service.dlp.DlpService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Service;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

// 해당 프로세스의 시작점
@Service
@Slf4j
public class FileEventListenerService {

    private final FileUploadRepo fileUploadRepo;
    private final StoredFileRepo storedFileRepo;
    private final RabbitTemplate rabbitTemplate;
    private final RabbitTemplate alertsRabbitTemplate;
    private final FileStatusService fileStatusService;
    private final DlpService dlpService;
    private final RabbitMQProperties properties;

    public FileEventListenerService(FileUploadRepo fileUploadRepo, StoredFileRepo storedFileRepo, @Qualifier("rabbitTemplate") RabbitTemplate rabbitTemplate, @Qualifier("alertsRabbitTemplate") RabbitTemplate alertsRabbitTemplate,
                                    FileStatusService fileStatusService, RabbitMQProperties properties
                                    , DlpService dlpService) {
        this.fileUploadRepo = fileUploadRepo;
        this.storedFileRepo = storedFileRepo;
        this.rabbitTemplate = rabbitTemplate;
        this.alertsRabbitTemplate = alertsRabbitTemplate;
        this.fileStatusService = fileStatusService;
        this.properties = properties;
        this.dlpService = dlpService;
    }

    @RabbitListener(queues = "#{@rabbitMQProperties.fileQueue}")
    public void executeFileTask(long uploadId) {
        try {
            log.info("Processing file with ID: {}", uploadId);

            FileUpload fileUpload = fileUploadRepo.findById(uploadId)
                    .orElseThrow(() -> new IllegalArgumentException("FileUpload not found for id: " + uploadId));

            StoredFile storedFile = findStoredFileWithPolling(fileUpload, 5, 5);

            // DLP 진행하는 부분
            dlpService.dlpFunc(uploadId);
            log.info("storedFile id: {}", storedFile.getId());
            FileStatus fileStatus = storedFile.getFileStatus();
            if (fileStatus == null) {
                log.info("null");
                // FileStatus가 null일 경우, 새로운 파일로 간주
                long storedFileId = storedFile.getId();
                fileStatusService.createFileStatus(storedFileId);
                // Vt Report 전송
                rabbitTemplate.convertAndSend(properties.getExchange(), properties.getVtReportRoutingKey(), uploadId);
                rabbitTemplate.convertAndSend(properties.getExchange(), properties.getGrmScanRoutingKey(), uploadId);
                return;
            }

            // VtStatus가 -1일 경우 처리
            if (fileStatus.getVtStatus() == -1) {
                log.info("vt -1");
                rabbitTemplate.convertAndSend(properties.getExchange(), properties.getVtReportRoutingKey(), uploadId);

            }
            // GscanStatus -1일 경우 처리
            if (fileStatus.getGscanStatus() == -1) {
                log.info("gscan -1");
                rabbitTemplate.convertAndSend(properties.getExchange(), properties.getGrmScanRoutingKey(), uploadId);
            }

            // 아무 이상이 없는 경우 Alerts 전송
            alertsRabbitTemplate.convertAndSend(properties.getAlertsExchange(), properties.getAlertsUploadRoutingKey(), uploadId);

        } catch (IllegalArgumentException e) {
            log.error("Invalid data provided for file upload id: " + uploadId, e);
        } catch (Exception e) {
            log.error("Error processing file with file upload id: " + uploadId, e);
        }
    }

    public StoredFile findStoredFileWithPolling(FileUpload fileUpload, int maxRetries, int delayInSeconds) {
        ScheduledExecutorService executorService = Executors.newSingleThreadScheduledExecutor();

        for (int i = 0; i < maxRetries; i++) {
            try {
                // 해시값으로 StoredFile을 찾기 시도
                return storedFileRepo.findByHash(fileUpload.getHash())
                        .orElseThrow(() -> new IllegalArgumentException("StoredFile not found for hash: " + fileUpload.getHash()));
            } catch (IllegalArgumentException e) {
                // 파일이 없으면 지정된 시간만큼 대기 후 재시도
                try {
                    log.info("StoredFile not found. Retrying in " + delayInSeconds + " seconds...");
                    TimeUnit.SECONDS.sleep(delayInSeconds);
                } catch (InterruptedException ie) {
                    Thread.currentThread().interrupt(); // 인터럽트 상태를 복원
                    throw new RuntimeException("Thread interrupted during polling");
                }
            }
        }

        // 최종적으로 실패하면 예외 처리
        throw new IllegalArgumentException("StoredFile not found after " + maxRetries + " attempts for hash: " + fileUpload.getHash());
    }


}


