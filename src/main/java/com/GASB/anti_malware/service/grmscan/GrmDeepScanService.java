package com.GASB.anti_malware.service.grmscan;

import com.GASB.anti_malware.model.entity.FileUpload;
import com.GASB.anti_malware.model.entity.Gscan;
import com.GASB.anti_malware.model.entity.StoredFile;
import com.GASB.anti_malware.repository.file.FileUploadRepo;
import com.GASB.anti_malware.repository.file.GscanRepo;
import com.GASB.anti_malware.repository.file.StoredFileRepo;
import com.GASB.anti_malware.service.FileStatusService;
import org.slf4j.Logger;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Service;
import com.GASB.anti_malware.config.RabbitMQProperties;

import java.util.Optional;

import org.slf4j.LoggerFactory;
import org.springframework.transaction.annotation.Transactional;

@Service
public class GrmDeepScanService {

    private static final Logger logger = LoggerFactory.getLogger(GrmDeepScanService.class);

    private final FileUploadRepo fileUploadRepo;
    private final StoredFileRepo storedFileRepository;
    private final FileStatusService fileStatusService;
    private final GscanRepo gscanRepo;
    private final RabbitTemplate rabbitTemplate;
    private final RabbitMQProperties properties;

    @Autowired
    public GrmDeepScanService(FileUploadRepo fileUploadRepo, StoredFileRepo storedFileRepository, FileStatusService fileStatusService, GscanRepo gscanRepo, @Qualifier("rabbitTemplate") RabbitTemplate rabbitTemplate, RabbitMQProperties properties) {
        this.fileUploadRepo = fileUploadRepo;
        this.storedFileRepository = storedFileRepository;
        this.fileStatusService = fileStatusService;
        this.gscanRepo = gscanRepo;
        this.rabbitTemplate = rabbitTemplate;
        this.properties = properties;
    }

    // 서비스를 하나씩 더 만드는 게 나을 듯
    // 스캔 끝나면 grm_status 1로 업데이트 하기 (sprint 2)
    @Async("taskExecutor")
    public void deepScanStart(long uploadId) {
        try {
            Optional<FileUpload> fileUploadOptional = fileUploadRepo.findById(uploadId);
            FileUpload fileUpload = fileUploadOptional.orElseThrow(() ->
                    new IllegalArgumentException("FileUpload not found for id: " + uploadId)
            );
            Optional<StoredFile> storedFileOptional = storedFileRepository.findByHash(fileUpload.getHash());
            StoredFile storedFile = storedFileOptional.orElseThrow(() ->
                    new IllegalArgumentException("StoredFile not found for hash: " + fileUpload.getHash())
            );

            String type = returnType(storedFile);
            String fileIdtoString = String.valueOf(uploadId);
            switch (type) {
                case "exe" -> {
                    // 실행 파일에 대한 처리
                    logger.info("Executing scan for executable file");
                    rabbitTemplate.convertAndSend(properties.getExchange(), properties.getExeScanRoutingKey(), fileIdtoString);
                }
                case "img" -> {
                    // 이미지 파일에 대한 처리
                    logger.info("Executing scan for image file");
                    rabbitTemplate.convertAndSend(properties.getExchange(), properties.getImgScanRoutingKey(), fileIdtoString);
                }
                case "doc" -> {
                    // 문서 파일에 대한 처리
                    logger.info("Executing scan for document file");
                    rabbitTemplate.convertAndSend(properties.getExchange(), properties.getDocScanRoutingKey(), fileIdtoString);
                }
                default -> {
                    saveUnsupportedFiles(storedFile);
                    fileStatusService.updateGscanStatus(storedFile.getId());
                    logger.info("Executing scan for other types of file");
                }

            }
        } catch (Exception e) {
            logger.error("Unexpected error during deep scan for file ID: {}", uploadId, e);
        }
    }

    private String returnType(StoredFile storedFile) {
        String type = storedFile.getType();

        return switch (type.toLowerCase()) {
            case "exe", "dll", "elf" -> "exe";
            case "jpg", "jpeg", "png", "gif", "svg", "webp" -> "img";
            case "docx", "hwp", "doc", "xls", "xlsx", "ppt", "pptx", "pdf", "text", "html" -> "doc";
            default -> {
                logger.warn("Unknown file type for file ID: {}, type: {}", storedFile.getId(), type);
                yield "else";
            }
        };
    }

    @Transactional
    public void saveUnsupportedFiles(StoredFile storedFile) {
        // Gscan 엔티티 생성
        Gscan unsupportedScan = Gscan.builder()
                .storedFile(storedFile)
                .step2Detail("Unsupported File Format")
                .detected(false)
                .build();

        // Gscan 엔티티 저장
        gscanRepo.save(unsupportedScan);

        logger.info("Unsupported file saved in Gscan table for file ID: {}", storedFile.getId());
    }

}
