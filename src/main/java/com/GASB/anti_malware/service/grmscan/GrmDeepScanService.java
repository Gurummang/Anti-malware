package com.GASB.anti_malware.service.grmscan;

import com.GASB.anti_malware.model.entity.StoredFile;
import com.GASB.anti_malware.repository.StoredFileRepository;
import org.slf4j.Logger;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Service;
import com.GASB.anti_malware.config.RabbitMQProperties;

import java.io.IOException;
import java.util.Optional;

import org.slf4j.LoggerFactory;

@Service
public class GrmDeepScanService {

    private static final Logger logger = LoggerFactory.getLogger(GrmDeepScanService.class);

    private final StoredFileRepository storedFileRepository;
    private final RabbitTemplate rabbitTemplate;
    private final RabbitMQProperties properties;

    @Autowired
    public GrmDeepScanService(StoredFileRepository storedFileRepository, RabbitTemplate rabbitTemplate, RabbitMQProperties properties){
        this.storedFileRepository = storedFileRepository;
        this.rabbitTemplate = rabbitTemplate;
        this.properties = properties;
    }

    // 서비스를 하나씩 더 만드는 게 나을 듯
    // 스캔 끝나면 grm_status 1로 업데이트 하기 (sprint 2)
    @Async("taskExecutor")
    public void deepScanStart(long fileId) {
        try {
            String type = returnType(fileId);
            switch (type) {
                case "exe" -> {
                    // 실행 파일에 대한 처리
                    System.out.println("Executing scan for executable file");
                    rabbitTemplate.convertAndSend(properties.getExchange(), properties.getExeScanRoutingKey(), fileId);
                }
                case "img" -> {
                    // 이미지 파일에 대한 처리
                    System.out.println("Executing scan for image file");
                    rabbitTemplate.convertAndSend(properties.getExchange(), properties.getImgScanRoutingKey(), fileId);
                }
                case "doc" -> {
                    // 문서 파일에 대한 처리
                    System.out.println("Executing scan for document file");
                    rabbitTemplate.convertAndSend(properties.getExchange(), properties.getDocScanRoutingKey(), fileId);
                }
                default -> {
                    // 기타 파일에 대한 처리
                    System.out.println("Executing scan for other types of file");
                }
            }
        } catch (IOException e) {
            logger.error("Error during deep scan for file ID: {}", fileId, e);
        } catch (Exception e) {
            logger.error("Unexpected error during deep scan for file ID: {}", fileId, e);
        }
    }

    private String returnType(long fileId) throws IOException{
        Optional<StoredFile> optionalStoredFile= storedFileRepository.findById(fileId);
        if (optionalStoredFile.isEmpty()) {
            logger.error("File not found with ID: {}", fileId);
            throw new IOException("File not found with ID: " + fileId);
        }

        StoredFile storedFile = optionalStoredFile.get();
        String type = storedFile.getType();

        return switch (type.toLowerCase()) {
            case "exe", "dll", "elf" -> "exe";
            case "jpg", "jpeg", "png", "gif", "svg", "webp" -> "img";
            case "docx", "hwp" ,"doc", "xls", "xlsx", "ppt", "pptx", "pdf", "text", "html" -> "doc";
            default -> {
                logger.warn("Unknown file type for file ID: {}, type: {}", fileId, type);
                yield "else";
            }
        };
    }
}
