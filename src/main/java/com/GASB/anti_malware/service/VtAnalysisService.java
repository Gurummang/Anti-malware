package com.GASB.anti_malware.service;

import com.GASB.anti_malware.model.entity.FileStatus;
import com.GASB.anti_malware.repository.FileStatusRepository;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;


@Service
public class VtAnalysisService {

        private static final Logger logger = LoggerFactory.getLogger(VtAnalysisService.class);
        private final RestTemplate restTemplate;
        private final FileStatusRepository fileStatusRepository;
        private final ObjectMapper objectMapper;

        @Value("${virustotal.api.key}")
        private String apikey;

        private static final int MAX_RETRIES = 10;  // 최대 재시도 횟수
        private static final int RETRY_INTERVAL = 10000;  // 재시도 간격 (밀리초 단위, 10초)

        private final String BASE_URL = "https://www.virustotal.com/api/v3/analyses/";

        @Autowired
        public VtAnalysisService(RestTemplate restTemplate, FileStatusRepository fileStatusRepository, ObjectMapper objectMapper) {
            this.restTemplate = restTemplate;
            this.fileStatusRepository = fileStatusRepository;
            this.objectMapper = objectMapper;
        }

        public void pollAnalysisStatus(String analysisId, long fileId) {
            int retries = 0;
            boolean isCompleted = false;

            while (retries < MAX_RETRIES && !isCompleted) {
                try {
                    Thread.sleep(RETRY_INTERVAL);
                    isCompleted = checkAnalysisStatus(analysisId, fileId);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    logger.error("Thread interrupted during sleep", e);
                    return;
                } catch (Exception e) {
                    logger.error("Error checking analysis status", e);
                }

                retries++;
            }

            if (!isCompleted) {
                logger.error("Analysis not completed within the maximum retries");
            }
        }

        private boolean checkAnalysisStatus(String analysisId, long fileId) {
            String url = BASE_URL + analysisId;

            HttpHeaders headers = new HttpHeaders();
            headers.set("x-apikey", apikey);
            HttpEntity<String> entity = new HttpEntity<>(headers);

            ResponseEntity<String> response = restTemplate.exchange(url, HttpMethod.GET, entity, String.class);

            if (response.getStatusCode() == HttpStatus.OK) {
                try {
                    JsonNode jsonNode = objectMapper.readTree(response.getBody());
                    String status = jsonNode.path("data").path("attributes").path("status").asText();

                    if ("completed".equals(status)) {
                        updateVtStatus(fileId, 1);
                        return true;
                    }

                } catch (Exception e) {
                    logger.error("Error parsing response", e);
                }
            } else {
                logger.error("Error fetching analysis status: " + response.getStatusCode());
            }

            return false;
        }

        private void updateVtStatus(long fileId, int newStatus) {
            FileStatus fileStatus = fileStatusRepository.findByStoredFileId(fileId);
            if (fileStatus != null) {
                fileStatus.setVtStatus(newStatus);
                fileStatusRepository.save(fileStatus);
                logger.info("VtStatus updated to " + newStatus + " for fileId: " + fileId);
            } else {
                logger.error("FileStatus not found for fileId: " + fileId);
            }
        }
    }
